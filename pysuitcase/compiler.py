import base64
import click
import os
import shutil
import subprocess
import sys
import glob

try:
    import importlib.resources as pkg_resources
except ImportError:
    import importlib_resources as pkg_resources

def is_pyqt5_project(project_dir, app_folder, requirements_file):
    """通过读取 requirements.txt 检查是否为 PyQt5 项目。"""
    req_path = os.path.join(project_dir, app_folder, requirements_file)
    if not os.path.exists(req_path):
        return False
    try:
        with open(req_path, 'r', encoding='utf-8') as f:
            for line in f:
                if 'pyqt5' in line.lower():
                    click.secho("PyQt5 project detected! Applying special launcher command.", fg='magenta')
                    return True
    except FileNotFoundError:
        return False
    return False

def encrypt_code(app_dir_path, delete_source=False):
    """使用 Cython 将 app 目录下的 .py 文件编译为 .pyd 文件。"""
    click.echo("\n-------------------------------------")
    click.secho("Encrypting source code with Cython...", fg='cyan', bold=True)
    all_py_files = glob.glob(os.path.join(app_dir_path, '**', '*.py'), recursive=True)
    files_to_compile = [f for f in all_py_files if os.path.basename(f) != 'pysuitcase_build.py']
    if not files_to_compile:
        click.secho("Warning: No Python files found to encrypt in the app folder.", fg='yellow')
        return

    click.echo("Found python files to compile:")
    for py_file in files_to_compile:
        click.echo(f"  - {os.path.basename(py_file)}")
        
    files_repr = repr([f.replace('\\', '/') for f in files_to_compile])

    build_script_content = f"""
# This file is auto-generated by pysuitcase.
from setuptools import setup
from Cython.Build import cythonize
setup(ext_modules=cythonize({files_repr}, language_level='3', quiet=True))
"""
    build_script_path = os.path.join(app_dir_path, 'pysuitcase_build.py')
    with open(build_script_path, 'w', encoding='utf-8') as f:
        f.write(build_script_content)

    compile_command = [sys.executable, 'pysuitcase_build.py', 'build_ext', '--inplace']
    click.echo(f"Running compilation command: {' '.join(compile_command)}")
    
    try:
        process = subprocess.run(compile_command, cwd=app_dir_path, check=True, capture_output=True, text=True, encoding='mbcs', errors='ignore')
        click.echo(process.stdout)
    except subprocess.CalledProcessError as e:
        click.secho("Cython compilation failed!", fg='red', bold=True)
        click.echo(e.stdout); click.secho(e.stderr, fg='red'); os.remove(build_script_path); sys.exit(1)

    click.echo("Cleaning up build files...")
    os.remove(build_script_path)
    shutil.rmtree(os.path.join(app_dir_path, 'build'), ignore_errors=True)
    
    for c_file in glob.glob(os.path.join(app_dir_path, '*.c')):
        os.remove(c_file)
    
    if delete_source:
        click.secho("Deleting source files and __pycache__ folders as requested...", fg='red')
        for py_file in files_to_compile:
            if os.path.basename(py_file) != '__init__.py' and os.path.exists(py_file):
                os.remove(py_file)
        for cache_dir in glob.glob(os.path.join(app_dir_path, '**/__pycache__'), recursive=True):
            shutil.rmtree(cache_dir, ignore_errors=True)
        click.secho("Source files deleted.", fg='red')
    else:
        click.secho("Original source files have been kept.", fg='green')


def compile_launcher(project_dir, app_folder, main_script, python_version, arch, requirements_file, icon_path=None):
    """编译一个简单、可靠的、永远带控制台的 C 语言启动器。"""
    click.echo("\n-------------------------------------")
    click.secho("Compiling Simple & Reliable C Launcher...", fg='cyan', bold=True)

    if not shutil.which("cl.exe") or not shutil.which("rc.exe"):
        click.secho("Error: 'cl.exe' or 'rc.exe' not found.", fg='red', bold=True)
        click.secho("Please run pysuitcase from a 'Developer Command Prompt for VS'.", fg='yellow'); sys.exit(1)
    
    click.echo("Found 'cl.exe' and 'rc.exe'.")

    with pkg_resources.path('pysuitcase.templates', 'default.ico') as default_icon_p:
        if icon_path and os.path.exists(icon_path):
            final_icon_path = icon_path
        else:
            final_icon_path = default_icon_p
        shutil.copy(final_icon_path, os.path.join(project_dir, 'app.ico'))
        
    with pkg_resources.path('pysuitcase.templates', 'resource.rc') as rc_template_p:
        shutil.copy(rc_template_p, os.path.join(project_dir, 'resource.rc'))
    rc_command = ["rc.exe", "/fo", "app.res", "resource.rc"]
    subprocess.run(rc_command, cwd=project_dir, check=True, capture_output=True)
    
    # 1. 准备 Python 命令的各个部分
    python_executable_name = "python.exe"
    python_folder = f"python-{python_version}-embed-{arch}"
    module_name = main_script.replace('.py', '')
    
    # Python 解释器的相对路径
    python_exe_rel_path = f"..\\{python_folder}\\{python_executable_name}"
    # Python 解释器的调用器，包含 -u 无缓冲标志
    python_invoker = f"{python_exe_rel_path} -u"
    
    # 要执行的 Python 代码
    code = f"import os,sys; sys.path.append(os.getcwd()); import {module_name}; {module_name}.run()"
    encoded = base64.b64encode(code.encode()).decode()
    python_code = f"import base64; exec(base64.b64decode('{encoded}').decode())"
    
    # 2. 构建我们希望 cmd.exe 最终看到的完整命令
    final_command = ""
    if is_pyqt5_project(project_dir, app_folder, requirements_file):
        qt_plugin_path = f"..\\{python_folder}\\Lib\\site-packages\\PyQt5\\Qt5\\plugins\\platforms"
        # 组装 PyQt5 的命令
        final_command = f'cd "{app_folder}" && set QT_QPA_PLATFORM_PLUGIN_PATH="{qt_plugin_path}" && {python_invoker} -c "{python_code}"'
    else:
        # 组装标准程序的命令
        final_command = f'cd "{app_folder}" && {python_invoker} -c "{python_code}"'
        
    # 3. 为 C 语言的字符串字面量进行最终的、正确的转义
    final_command_for_c_source = final_command.replace('\\', '\\\\').replace('"', '\\"')
    click.echo(f"Launcher will execute: {final_command}")
    
    # 4. 注入到 C 语言启动器模板
    c_template_path = pkg_resources.files('pysuitcase.templates') / 'launcher.c'
    c_code = c_template_path.read_text(encoding='utf-8')
    c_code = c_code.replace("{{COMMAND_STRING}}", final_command_for_c_source)
    
    build_c_path = os.path.join(project_dir, 'pysuitcase_launcher.c')
    with open(build_c_path, 'w', encoding='utf-8-sig') as f:
        f.write(c_code)

    # 5. 编译
    exe_name = f"{os.path.basename(project_dir)}.exe"
    subsystem = "/SUBSYSTEM:CONSOLE"
    
    cl_command = [
        "cl.exe", "/nologo", "/O2", "/W3",
        f"/Fe{exe_name}", build_c_path, "app.res", "User32.lib",
        "/link", subsystem
    ]
    
    click.echo(f"Running C compiler for {exe_name}...")
    try:
        process = subprocess.run(cl_command, cwd=project_dir, check=True, capture_output=True, encoding='mbcs', errors='ignore')
    except subprocess.CalledProcessError as e:
        click.secho("C compiler failed with an error:", fg='red', bold=True)
        click.echo(e.stdout)
        click.secho(e.stderr, fg='red')
        sys.exit(1)

    click.echo("Cleaning up intermediate files...")
    files_to_cleanup = ['pysuitcase_launcher.c', 'pysuitcase_launcher.obj', 'app.res', 'resource.rc', 'app.ico']
    for filename in files_to_cleanup:
        try:
            path_to_del = os.path.join(project_dir, filename)
            if os.path.exists(path_to_del):
                os.remove(path_to_del)
        except OSError as e:
            click.secho(f"Warning: Could not remove temporary file {filename}. Reason: {e}", fg='yellow')

    click.secho(f"\nSuccessfully compiled '{exe_name}' in {project_dir}", fg='green', bold=True)
    return True