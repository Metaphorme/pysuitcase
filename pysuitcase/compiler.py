import base64
import click
import os
import shutil
import subprocess
import sys
import glob

try:
    import importlib.resources as pkg_resources
except ImportError:
    import importlib_resources as pkg_resources

def is_pyqt5_project(project_dir, app_folder, requirements_file):
    """通过读取 requirements.txt 检查是否为 PyQt5 项目。"""
    req_path = os.path.join(project_dir, app_folder, requirements_file)
    if not os.path.exists(req_path):
        return False
    try:
        with open(req_path, 'r', encoding='utf-8') as f:
            for line in f:
                if 'pyqt5' in line.lower():
                    click.secho("PyQt5 project detected! Applying internal environment setup.", fg='magenta')
                    return True
    except FileNotFoundError:
        return False
    return False

def encrypt_code(app_dir_path, delete_source=False):
    """使用 Cython 将 app 目录下的 .py 文件编译为 .pyd 文件。"""
    click.echo("\n-------------------------------------")
    click.secho("Encrypting source code with Cython...", fg='cyan', bold=True)
    all_py_files = glob.glob(os.path.join(app_dir_path, '**', '*.py'), recursive=True)
    files_to_compile = [f for f in all_py_files if os.path.basename(f) != 'pysuitcase_build.py']
    if not files_to_compile:
        click.secho("Warning: No Python files found to encrypt in the app folder.", fg='yellow')
        return

    click.echo("Found python files to compile:")
    for py_file in files_to_compile:
        click.echo(f"  - {os.path.basename(py_file)}")
        
    files_repr = repr([f.replace('\\', '/') for f in files_to_compile])

    build_script_content = f"""
# This file is auto-generated by pysuitcase.
from setuptools import setup
from Cython.Build import cythonize
setup(ext_modules=cythonize({files_repr}, language_level='3', quiet=True))
"""
    build_script_path = os.path.join(app_dir_path, 'pysuitcase_build.py')
    with open(build_script_path, 'w', encoding='utf-8') as f:
        f.write(build_script_content)

    compile_command = [sys.executable, 'pysuitcase_build.py', 'build_ext', '--inplace']
    click.echo(f"Running compilation command: {' '.join(compile_command)}")
    
    try:
        process = subprocess.run(compile_command, cwd=app_dir_path, check=True, capture_output=True, text=True, encoding='mbcs', errors='ignore')
        click.echo(process.stdout)
    except subprocess.CalledProcessError as e:
        click.secho("Cython compilation failed!", fg='red', bold=True)
        click.echo(e.stdout); click.secho(e.stderr, fg='red'); os.remove(build_script_path); sys.exit(1)

    click.echo("Cleaning up build files...")
    os.remove(build_script_path)
    shutil.rmtree(os.path.join(app_dir_path, 'build'), ignore_errors=True)
    
    for c_file in glob.glob(os.path.join(app_dir_path, '*.c')):
        os.remove(c_file)
    
    if delete_source:
        click.secho("Deleting source files and __pycache__ folders as requested...", fg='red')
        for py_file in files_to_compile:
            if os.path.basename(py_file) != '__init__.py' and os.path.exists(py_file):
                os.remove(py_file)
        for cache_dir in glob.glob(os.path.join(app_dir_path, '**/__pycache__'), recursive=True):
            shutil.rmtree(cache_dir, ignore_errors=True)
        click.secho("Source files deleted.", fg='red')
    else:
        click.secho("Original source files have been kept.", fg='green')


def compile_launcher(project_dir, app_folder, main_script, python_version, arch, requirements_file, icon_path=None, no_window=False):
    """根据选择编译 C 语言启动器，支持标准控制台模式和无窗口模式。"""
    click.echo("\n-------------------------------------")
    if no_window:
        click.secho("Compiling Advanced (Windowless) C Launcher...", fg='cyan', bold=True)
    else:
        click.secho("Compiling Simple & Reliable C Launcher...", fg='cyan', bold=True)

    if not shutil.which("cl.exe") or not shutil.which("rc.exe"):
        click.secho("Error: 'cl.exe' or 'rc.exe' not found.", fg='red', bold=True)
        click.secho("Please run pysuitcase from a 'Developer Command Prompt for VS'.", fg='yellow'); sys.exit(1)
    
    click.echo("Found 'cl.exe' and 'rc.exe'.")

    # --- 资源文件处理 ---
    with pkg_resources.path('pysuitcase.templates', 'default.ico') as default_icon_p:
        if icon_path and os.path.exists(icon_path):
            final_icon_path = icon_path
        else:
            final_icon_path = default_icon_p
        shutil.copy(final_icon_path, os.path.join(project_dir, 'app.ico'))
        
    with pkg_resources.path('pysuitcase.templates', 'resource.rc') as rc_template_p:
        shutil.copy(rc_template_p, os.path.join(project_dir, 'resource.rc'))
    rc_command = ["rc.exe", "/fo", "app.res", "resource.rc"]
    subprocess.run(rc_command, cwd=project_dir, check=True, capture_output=True)
    
    # --- 1. 构建智能 Python 载荷 ---
    python_folder = f"python-{python_version}-embed-{arch}"
    module_name = main_script.replace('.py', '')

    py_payload_lines = [
        "import os, sys, base64",
        "sys.path.append(os.getcwd())",
    ]

    if is_pyqt5_project(project_dir, app_folder, requirements_file):
        # 计算相对路径，并为 Python 字符串正确转义
        qt_plugin_path = os.path.join('..', python_folder, 'Lib', 'site-packages', 'PyQt5', 'Qt5', 'plugins').replace('\\', '\\\\')
        py_payload_lines.append(f"os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = r'{qt_plugin_path}'")

    py_payload_lines.extend([
        f"import {module_name}",
        f"{module_name}.run()"
    ])
    
    py_payload = "; ".join(py_payload_lines)
    encoded_payload = base64.b64encode(py_payload.encode()).decode()
    
    # --- 2. 构建简化的命令行 ---
    python_exec_code = f"import base64, os; exec(base64.b64decode('{encoded_payload}').decode())"
    python_exe_path = os.path.join('..', python_folder, 'python.exe')
    
    # 最终的命令行现在非常简单
    final_command = f'{python_exe_path} -u -c "{python_exec_code}"'
    click.echo(f"Launcher will execute from '{app_folder}': {final_command}")

    # --- 3. 为 C 语言模板准备数据 ---
    final_command_for_c = final_command.replace('\\', '\\\\').replace('"', '\\"')
    app_folder_for_c = app_folder.replace('\\', '\\\\')

    c_template_name = 'launcher-no-window.c' if no_window else 'launcher.c'
    c_template_path = pkg_resources.files('pysuitcase.templates') / c_template_name
    
    c_code = c_template_path.read_text(encoding='utf-8')
    c_code = c_code.replace("{{COMMAND_STRING}}", final_command_for_c)
    c_code = c_code.replace("{{APP_FOLDER_NAME}}", app_folder_for_c) # 新的替换
    
    build_c_path = os.path.join(project_dir, 'pysuitcase_launcher.c')
    with open(build_c_path, 'w', encoding='utf-8-sig') as f:
        f.write(c_code)

    # --- 4. 编译启动器 ---
    exe_name = f"{os.path.basename(project_dir)}.exe"
    subsystem = "/SUBSYSTEM:WINDOWS" if no_window else "/SUBSYSTEM:CONSOLE"
    
    cl_command = [
        "cl.exe", "/nologo", "/O2", "/W3",
        f"/Fe{exe_name}", build_c_path, "app.res", "User32.lib",
        "/link", subsystem
    ]
    
    click.echo(f"Running C compiler for {exe_name} with {subsystem}...")
    try:
        process = subprocess.run(cl_command, cwd=project_dir, check=True, capture_output=True, encoding='mbcs', errors='ignore')
    except subprocess.CalledProcessError as e:
        click.secho("C compiler failed with an error:", fg='red', bold=True)
        click.echo(e.stdout)
        click.secho(e.stderr, fg='red')
        sys.exit(1)

    # --- 5. 清理 ---
    click.echo("Cleaning up intermediate files...")
    files_to_cleanup = ['pysuitcase_launcher.c', 'pysuitcase_launcher.obj', 'app.res', 'resource.rc', 'app.ico']
    for filename in files_to_cleanup:
        try:
            path_to_del = os.path.join(project_dir, filename)
            if os.path.exists(path_to_del):
                os.remove(path_to_del)
        except OSError as e:
            click.secho(f"Warning: Could not remove temporary file {filename}. Reason: {e}", fg='yellow')

    click.secho(f"\nSuccessfully compiled '{exe_name}' in {project_dir}", fg='green', bold=True)
    return True